[
  {
    "advisory": {
      "id": "RUSTSEC-2021-0097",
      "package": "openssl-src",
      "title": "SM2 Decryption Buffer Overflow",
      "description": "In order to decrypt SM2 encrypted data an application is expected to call the\nAPI function `EVP_PKEY_decrypt()`. Typically an application will call this\nfunction twice. The first time, on entry, the \"out\" parameter can be NULL and,\non exit, the \"outlen\" parameter is populated with the buffer size required to\nhold the decrypted plaintext. The application can then allocate a sufficiently\nsized buffer and call `EVP_PKEY_decrypt()` again, but this time passing a non-NULL\nvalue for the \"out\" parameter.\n\nA bug in the implementation of the SM2 decryption code means that the\ncalculation of the buffer size required to hold the plaintext returned by the\nfirst call to `EVP_PKEY_decrypt()` can be smaller than the actual size required by\nthe second call. This can lead to a buffer overflow when `EVP_PKEY_decrypt()` is\ncalled by the application a second time with a buffer that is too small.\n\nA malicious attacker who is able present SM2 content for decryption to an\napplication could cause attacker chosen data to overflow the buffer by up to a\nmaximum of 62 bytes altering the contents of other data held after the\nbuffer, possibly changing application behaviour or causing the application to\ncrash. The location of the buffer is application dependent but is typically\nheap allocated.",
      "date": "2021-08-24",
      "aliases": [
        "CVE-2021-3711"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20210824.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.16"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2020-0015",
      "package": "openssl-src",
      "title": "Crash causing Denial of Service attack",
      "description": "Server or client applications that call the SSL_check_chain() function during or after a TLS 1.3 \nhandshake may crash due to a NULL pointer dereference as a result of incorrect handling of the \n\"signature_algorithms_cert\" TLS extension. The crash occurs if an invalid or unrecognised signature \nalgorithm is received from the peer. This could be exploited by a malicious peer in a Denial of \nService attack.",
      "date": "2020-04-25",
      "aliases": [
        "CVE-2020-1967"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20200421.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.9"
      ],
      "unaffected": [
        "<111.6"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0014",
      "package": "openssl-src",
      "title": "Infinite loop in `BN_mod_sqrt()` reachable when parsing certificates",
      "description": "The `BN_mod_sqrt()` function, which computes a modular square root, contains\na bug that can cause it to loop forever for non-prime moduli.\n\nInternally this function is used when parsing certificates that contain\nelliptic curve public keys in compressed form or explicit elliptic curve\nparameters with a base point encoded in compressed form.\n\nIt is possible to trigger the infinite loop by crafting a certificate that\nhas invalid explicit curve parameters.\n\nSince certificate parsing happens prior to verification of the certificate\nsignature, any process that parses an externally supplied certificate may thus\nbe subject to a denial of service attack. The infinite loop can also be\nreached when parsing crafted private keys as they can contain explicit\nelliptic curve parameters.\n\nThus vulnerable situations include:\n\n - TLS clients consuming server certificates\n - TLS servers consuming client certificates\n - Hosting providers taking certificates or private keys from customers\n - Certificate authorities parsing certification requests from subscribers\n - Anything else which parses ASN.1 elliptic curve parameters\n\nAlso any other applications that use the `BN_mod_sqrt()` where the attacker\ncan control the parameter values are vulnerable to this DoS issue.",
      "date": "2022-03-15",
      "aliases": [
        "CVE-2022-0778"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20220315.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.18, <300.0",
        ">=300.0.5"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0009",
      "package": "openssl-src",
      "title": "Use-after-free following `BIO_new_NDEF`",
      "description": "The public API function `BIO_new_NDEF` is a helper function used for streaming\nASN.1 data via a `BIO`. It is primarily used internally to OpenSSL to support the\nSMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by\nend user applications.\n\nThe function receives a `BIO` from the caller, prepends a new `BIO_f_asn1` filter\n`BIO` onto the front of it to form a `BIO` chain, and then returns the new head of\nthe `BIO` chain to the caller. Under certain conditions, for example if a CMS\nrecipient public key is invalid, the new filter `BIO` is freed and the function\nreturns a `NULL` result indicating a failure. However, in this case, the `BIO` chain\nis not properly cleaned up and the `BIO` passed by the caller still retains\ninternal pointers to the previously freed filter `BIO`. If the caller then goes on\nto call `BIO_pop()` on the `BIO` then a use-after-free will occur. This will most\nlikely result in a crash.\n\nThis scenario occurs directly in the internal function `B64_write_ASN1()` which\nmay cause `BIO_new_NDEF()` to be called and will subsequently call `BIO_pop()` on\nthe `BIO`. This internal function is in turn called by the public API functions\n`PEM_write_bio_ASN1_stream`, `PEM_write_bio_CMS_stream`, `PEM_write_bio_PKCS7_stream`,\n`SMIME_write_ASN1`, `SMIME_write_CMS` and `SMIME_write_PKCS7`.\n\nOther public API functions that may be impacted by this include\n`i2d_ASN1_bio_stream`, `BIO_new_CMS`, `BIO_new_PKCS7`, `i2d_CMS_bio_stream` and\n`i2d_PKCS7_bio_stream`.",
      "date": "2023-02-07",
      "aliases": [
        "CVE-2023-0215"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20230207.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.25, <300.0",
        ">=300.0.12"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0011",
      "package": "openssl-src",
      "title": "Invalid pointer dereference in `d2i_PKCS7` functions",
      "description": "An invalid pointer dereference on read can be triggered when an\napplication tries to load malformed PKCS7 data with the\n`d2i_PKCS7()`, `d2i_PKCS7_bio()` or `d2i_PKCS7_fp()` functions.\n\nThe result of the dereference is an application crash which could\nlead to a denial of service attack. The TLS implementation in OpenSSL\ndoes not call this function however third party applications might\ncall these functions on untrusted data.",
      "date": "2023-02-07",
      "aliases": [
        "CVE-2023-0216"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20230207.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.12"
      ],
      "unaffected": [
        "<300.0.0"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0006",
      "package": "openssl-src",
      "title": "X.400 address type confusion in X.509 `GeneralName`",
      "description": "There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 `GeneralName`. X.400 addresses were parsed as an `ASN1_STRING` but\nthe public structure definition for `GENERAL_NAME` incorrectly specified the type\nof the `x400Address` field as `ASN1_TYPE`. This field is subsequently interpreted by\nthe OpenSSL function `GENERAL_NAME_cmp` as an `ASN1_TYPE` rather than an\n`ASN1_STRING`.\n\nWhen CRL checking is enabled (i.e. the application sets the\n`X509_V_FLAG_CRL_CHECK` flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a `memcmp` call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.",
      "date": "2023-02-07",
      "aliases": [
        "CVE-2023-0286"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service",
        "memory-exposure"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20230207.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.25, <300.0",
        ">=300.0.12"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0129",
      "package": "openssl-src",
      "title": "Invalid handling of `X509_verify_cert()` internal errors in libssl",
      "description": "Internally libssl in OpenSSL calls `X509_verify_cert()` on the client side to\nverify a certificate supplied by a server. That function may return a negative\nreturn value to indicate an internal error (for example out of memory). Such a\nnegative return value is mishandled by OpenSSL and will cause an IO function\n(such as `SSL_connect()` or `SSL_do_handshake()`) to not indicate success and a\nsubsequent call to `SSL_get_error()` to return the value\n`SSL_ERROR_WANT_RETRY_VERIFY`. This return value is only supposed to be returned\nby OpenSSL if the application has previously called\n`SSL_CTX_set_cert_verify_callback()`. Since most applications do not do this the\n`SSL_ERROR_WANT_RETRY_VERIFY` return value from `SSL_get_error()` will be totally\nunexpected and applications may not behave correctly as a result. The exact\nbehaviour will depend on the application but it could result in crashes,\ninfinite loops or other similar incorrect responses.\n\nThis issue is made more serious in combination with a separate bug in OpenSSL\n3.0 that will cause `X509_verify_cert()` to indicate an internal error when\nprocessing a certificate chain. This will occur where a certificate does not\ninclude the Subject Alternative Name extension but where a Certificate Authority\nhas enforced name constraints. This issue can occur even with valid chains.",
      "date": "2021-12-14",
      "aliases": [
        "CVE-2021-4044"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20211214.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.4"
      ],
      "unaffected": [
        "<300.0.0"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0008",
      "package": "openssl-src",
      "title": "X.509 Name Constraints Read Buffer Overflow",
      "description": "A read buffer overrun can be triggered in X.509 certificate verification,\nspecifically in name constraint checking. Note that this occurs\nafter certificate chain signature verification and requires either a\nCA to have signed the malicious certificate or for the application to\ncontinue certificate verification despite failure to construct a path\nto a trusted issuer.\n\nThe read buffer overrun might result in a crash which could lead to\na denial of service attack. In theory it could also result in the disclosure\nof private memory contents (such as private keys, or sensitive plaintext)\nalthough we are not aware of any working exploit leading to memory\ncontents disclosure as of the time of release of this advisory.\n\nIn a TLS client, this can be triggered by connecting to a malicious\nserver. In a TLS server, this can be triggered if the server requests\nclient authentication and a malicious client connects.",
      "date": "2023-02-07",
      "aliases": [
        "CVE-2022-4203"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service",
        "memory-exposure"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20230207.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.12"
      ],
      "unaffected": [
        "<300.0.0"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0027",
      "package": "openssl-src",
      "title": "`OCSP_basic_verify` may incorrectly verify the response signing certificate",
      "description": "The function `OCSP_basic_verify` verifies the signer certificate on an OCSP\nresponse. In the case where the (non-default) flag OCSP_NOCHECKS is used then\nthe response will be positive (meaning a successful verification) even in the\ncase where the response signing certificate fails to verify.\n\nIt is anticipated that most users of `OCSP_basic_verify` will not use the\nOCSP_NOCHECKS flag. In this case the `OCSP_basic_verify` function will return\na negative value (indicating a fatal error) in the case of a certificate\nverification failure. The normal expected return value in this case would be 0.",
      "date": "2022-05-03",
      "aliases": [
        "CVE-2022-1343"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20220503.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.6"
      ],
      "unaffected": [
        "<300.0"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0012",
      "package": "openssl-src",
      "title": "`NULL` dereference validating DSA public key",
      "description": "An invalid pointer dereference on read can be triggered when an\napplication tries to check a malformed DSA public key by the\n`EVP_PKEY_public_check()` function. This will most likely lead\nto an application crash. This function can be called on public\nkeys supplied from untrusted sources which could allow an attacker\nto cause a denial of service attack.\n\nThe TLS implementation in OpenSSL does not call this function\nbut applications might call the function if there are additional\nsecurity requirements imposed by standards such as FIPS 140-3.",
      "date": "2023-02-07",
      "aliases": [
        "CVE-2023-0217"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20230207.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.12"
      ],
      "unaffected": [
        "<300.0.0"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0056",
      "package": "openssl-src",
      "title": "CA certificate check bypass with X509_V_FLAG_X509_STRICT",
      "description": "The X509_V_FLAG_X509_STRICT flag enables additional security checks of the\ncertificates present in a certificate chain. It is not set by default.\n\nStarting from OpenSSL version 1.1.1h a check to disallow certificates in\nthe chain that have explicitly encoded elliptic curve parameters was added\nas an additional strict check.\n\nAn error in the implementation of this check meant that the result of a\nprevious check to confirm that certificates in the chain are valid CA\ncertificates was overwritten. This effectively bypasses the check\nthat non-CA certificates must not be able to issue other certificates.\n\nIf a \"purpose\" has been configured then there is a subsequent opportunity\nfor checks that the certificate is a valid CA.  All of the named \"purpose\"\nvalues implemented in libcrypto perform this check.  Therefore, where\na purpose is set the certificate chain will still be rejected even when the\nstrict flag has been used. A purpose is set by default in libssl client and\nserver certificate verification routines, but it can be overridden or\nremoved by an application.\n\nIn order to be affected, an application must explicitly set the\nX509_V_FLAG_X509_STRICT verification flag and either not set a purpose\nfor the certificate verification or, in the case of TLS client or server\napplications, override the default purpose.",
      "date": "2021-05-01",
      "aliases": [
        "CVE-2021-3450"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20210325.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.15"
      ],
      "unaffected": [
        "<111.11"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0033",
      "package": "openssl-src",
      "title": "Heap memory corruption with RSA private key operation",
      "description": "The OpenSSL 3.0.4 release introduced a serious bug in the RSA\nimplementation for X86_64 CPUs supporting the AVX512IFMA instructions.\nThis issue makes the RSA implementation with 2048 bit private keys\nincorrect on such machines and memory corruption will happen during\nthe computation. As a consequence of the memory corruption an attacker\nmay be able to trigger a remote code execution on the machine performing\nthe computation.\n\nSSL/TLS servers or other servers using 2048 bit RSA private keys running\non machines supporting AVX512IFMA instructions of the X86_64 architecture\nare affected by this issue.\n\nNote that on a vulnerable machine, proper testing of OpenSSL would fail and\nshould be noticed before deployment.",
      "date": "2022-07-05",
      "aliases": [
        "CVE-2022-2274"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20220705.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.9"
      ],
      "unaffected": [
        "<300.0.8"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0055",
      "package": "openssl-src",
      "title": "NULL pointer deref in signature_algorithms processing",
      "description": "An OpenSSL TLS server may crash if sent a maliciously crafted renegotiation\nClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits\nthe signature_algorithms extension (where it was present in the initial\nClientHello), but includes a signature_algorithms_cert extension then a NULL\npointer dereference will result, leading to a crash and a denial of service\nattack.\n\nA server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which\nis the default configuration). OpenSSL TLS clients are not impacted by this\nissue.",
      "date": "2021-05-01",
      "aliases": [
        "CVE-2021-3449"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20210325.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.15"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0013",
      "package": "openssl-src",
      "title": "`NULL` dereference during PKCS7 data verification",
      "description": "A `NULL` pointer can be dereferenced when signatures are being\nverified on PKCS7 `signed` or `signedAndEnveloped` data. In case the hash\nalgorithm used for the signature is known to the OpenSSL library but\nthe implementation of the hash algorithm is not available the digest\ninitialization will fail. There is a missing check for the return\nvalue from the initialization function which later leads to invalid\nusage of the digest API most likely leading to a crash.\n\nThe unavailability of an algorithm can be caused by using FIPS\nenabled configuration of providers or more commonly by not loading\nthe legacy provider.\n\nPKCS7 data is processed by the SMIME library calls and also by the\ntime stamp (TS) library calls. The TLS implementation in OpenSSL does\nnot call these functions however third party applications would be\naffected if they call these functions to verify signatures on untrusted\ndata.",
      "date": "2023-02-07",
      "aliases": [
        "CVE-2023-0401"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20230207.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.12"
      ],
      "unaffected": [
        "<300.0.0"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0059",
      "package": "openssl-src",
      "title": "Using a Custom Cipher with `NID_undef` may lead to NULL encryption",
      "description": "OpenSSL supports creating a custom cipher via the legacy `EVP_CIPHER_meth_new()`\nfunction and associated function calls. This function was deprecated in OpenSSL\n3.0 and application authors are instead encouraged to use the new provider\nmechanism in order to implement custom ciphers.\n\nOpenSSL versions 3.0.0 to 3.0.5 incorrectly handle legacy custom ciphers passed\nto the `EVP_EncryptInit_ex2()`, `EVP_DecryptInit_ex2()` and `EVP_CipherInit_ex2()`\nfunctions (as well as other similarly named encryption and decryption\ninitialisation functions). Instead of using the custom cipher directly it\nincorrectly tries to fetch an equivalent cipher from the available providers.\nAn equivalent cipher is found based on the NID passed to `EVP_CIPHER_meth_new()`.\nThis NID is supposed to represent the unique NID for a given cipher. However it\nis possible for an application to incorrectly pass `NID_undef` as this value in\nthe call to `EVP_CIPHER_meth_new()`. When `NID_undef` is used in this way the\nOpenSSL encryption/decryption initialisation function will match the NULL cipher\nas being equivalent and will fetch this from the available providers. This will\nsucceed if the default provider has been loaded (or if a third party provider\nhas been loaded that offers this cipher). Using the NULL cipher means that the\nplaintext is emitted as the ciphertext.\n\nApplications are only affected by this issue if they call `EVP_CIPHER_meth_new()`\nusing `NID_undef` and subsequently use it in a call to an encryption/decryption\ninitialisation function. Applications that only use SSL/TLS are not impacted by\nthis issue.",
      "date": "2022-10-11",
      "aliases": [
        "CVE-2022-3358"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20221011.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.10"
      ],
      "unaffected": [
        "<300.0.0"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0007",
      "package": "openssl-src",
      "title": "Timing Oracle in RSA Decryption",
      "description": "A timing based side channel exists in the OpenSSL RSA Decryption implementation\nwhich could be sufficient to recover a plaintext across a network in a\nBleichenbacher style attack. To achieve a successful decryption an attacker\nwould have to be able to send a very large number of trial messages for\ndecryption. The vulnerability affects all RSA padding modes: PKCS#1 v1.5,\nRSA-OEAP and RSASVE.\n\nFor example, in a TLS connection, RSA is commonly used by a client to send an\nencrypted pre-master secret to the server. An attacker that had observed a\ngenuine connection between a client and a server could use this flaw to send\ntrial messages to the server and record the time taken to process them. After a\nsufficiently large number of messages the attacker could recover the pre-master\nsecret used for the original connection and thus be able to decrypt the\napplication data sent over that connection.",
      "date": "2023-02-07",
      "aliases": [
        "CVE-2022-4304"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20230207.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.25, <300.0",
        ">=300.0.12"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0058",
      "package": "openssl-src",
      "title": "Null pointer deref in `X509_issuer_and_serial_hash()`",
      "description": "The OpenSSL public API function `X509_issuer_and_serial_hash()` attempts to\ncreate a unique hash value based on the issuer and serial number data contained\nwithin an X509 certificate. However it fails to correctly handle any errors\nthat may occur while parsing the issuer field (which might occur if the issuer\nfield is maliciously constructed). This may subsequently result in a NULL\npointer deref and a crash leading to a potential denial of service attack.\n\nThe function `X509_issuer_and_serial_hash()` is never directly called by OpenSSL\nitself so applications are only vulnerable if they use this function directly\nand they use it on certificates that may have been obtained from untrusted\nsources.",
      "date": "2021-05-01",
      "aliases": [
        "CVE-2021-23841"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20210216.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.14"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0098",
      "package": "openssl-src",
      "title": "Read buffer overruns processing ASN.1 strings",
      "description": "ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING\nstructure which contains a buffer holding the string data and a field holding\nthe buffer length. This contrasts with normal C strings which are represented as\na buffer for the string data which is terminated with a NUL (0) byte.\n\nAlthough not a strict requirement, ASN.1 strings that are parsed using OpenSSL's\nown \"d2i\" functions (and other similar parsing functions) as well as any string\nwhose value has been set with the ASN1_STRING_set() function will additionally\nNUL terminate the byte array in the ASN1_STRING structure.\n\nHowever, it is possible for applications to directly construct valid ASN1_STRING\nstructures which do not NUL terminate the byte array by directly setting the\n\"data\" and \"length\" fields in the ASN1_STRING array. This can also happen by\nusing the `ASN1_STRING_set0()` function.\n\nNumerous OpenSSL functions that print ASN.1 data have been found to assume that\nthe ASN1_STRING byte array will be NUL terminated, even though this is not\nguaranteed for strings that have been directly constructed. Where an application\nrequests an ASN.1 structure to be printed, and where that ASN.1 structure\ncontains ASN1_STRINGs that have been directly constructed by the application\nwithout NUL terminating the \"data\" field, then a read buffer overrun can occur.\n\nThe same thing can also occur during name constraints processing of certificates\n(for example if a certificate has been directly constructed by the application\ninstead of loading it via the OpenSSL parsing functions, and the certificate\ncontains non NUL terminated ASN1_STRING structures). It can also occur in the\n`X509_get1_email()`, `X509_REQ_get1_email()` and `X509_get1_ocsp()` functions.\n\nIf a malicious actor can cause an application to directly construct an\nASN1_STRING and then process it through one of the affected OpenSSL functions\nthen this issue could be hit. This might result in a crash (causing a Denial of\nService attack). It could also result in the disclosure of private memory\ncontents (such as private keys, or sensitive plaintext).",
      "date": "2021-08-24",
      "aliases": [
        "CVE-2021-3712"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service",
        "crypto-failure"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:H",
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20210824.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.16"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0032",
      "package": "openssl-src",
      "title": "AES OCB fails to encrypt some bytes",
      "description": "AES OCB mode for 32-bit x86 platforms using the AES-NI assembly optimised\nimplementation will not encrypt the entirety of the data under some\ncircumstances.  This could reveal sixteen bytes of data that was\npreexisting in the memory that wasn't written.  In the special case of\n\"in place\" encryption, sixteen bytes of the plaintext would be revealed.\n\nSince OpenSSL does not support OCB based cipher suites for TLS and DTLS,\nthey are both unaffected.",
      "date": "2022-07-05",
      "aliases": [
        "CVE-2022-2097"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20220705.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.22, <300.0",
        ">=300.0.9"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2021-0057",
      "package": "openssl-src",
      "title": "Integer overflow in CipherUpdate",
      "description": "Calls to `EVP_CipherUpdate`, `EVP_EncryptUpdate` and `EVP_DecryptUpdate` may overflow\nthe output length argument in some cases where the input length is close to the\nmaximum permissable length for an integer on the platform. In such cases the\nreturn value from the function call will be 1 (indicating success), but the\noutput length value will be negative. This could cause applications to behave\nincorrectly or crash.",
      "date": "2021-05-01",
      "aliases": [
        "CVE-2021-23840"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20210216.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.14"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0065",
      "package": "openssl-src",
      "title": "X.509 Email Address Variable Length Buffer Overflow",
      "description": "A buffer overrun can be triggered in X.509 certificate verification,\nspecifically in name constraint checking. Note that this occurs after\ncertificate chain signature verification and requires either a CA to\nhave signed a malicious certificate or for an application to continue\ncertificate verification despite failure to construct a path to a trusted\nissuer. An attacker can craft a malicious email address in a certificate\nto overflow an arbitrary number of bytes containing the `.` character\n(decimal 46) on the stack. This buffer overflow could result in a crash\n(causing a denial of service).\n\nIn a TLS client, this can be triggered by connecting to a malicious\nserver. In a TLS server, this can be triggered if the server requests\nclient authentication and a malicious client connects.",
      "date": "2022-11-01",
      "aliases": [
        "CVE-2022-3786"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20221101.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.11"
      ],
      "unaffected": [
        "<300.0.0"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0025",
      "package": "openssl-src",
      "title": "Resource leakage when decoding certificates and keys",
      "description": "The `OPENSSL_LH_flush()` function, which empties a hash table, contains\na bug that breaks reuse of the memory occupied by the removed hash\ntable entries.\n\nThis function is used when decoding certificates or keys. If a long lived\nprocess periodically decodes certificates or keys its memory usage will\nexpand without bounds and the process might be terminated by the operating\nsystem causing a denial of service. Also traversing the empty hash table\nentries will take increasingly more time.\n\nTypically such long lived processes might be TLS clients or TLS servers\nconfigured to accept client certificate authentication.",
      "date": "2022-05-03",
      "aliases": [
        "CVE-2022-1473"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20220503.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.6"
      ],
      "unaffected": [
        "<300.0"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0064",
      "package": "openssl-src",
      "title": "X.509 Email Address 4-byte Buffer Overflow",
      "description": "A buffer overrun can be triggered in X.509 certificate verification,\nspecifically in name constraint checking. Note that this occurs\nafter certificate chain signature verification and requires either a\nCA to have signed the malicious certificate or for the application to\ncontinue certificate verification despite failure to construct a path\nto a trusted issuer. An attacker can craft a malicious email address\nto overflow four attacker-controlled bytes on the stack. This buffer\noverflow could result in a crash (causing a denial of service) or\npotentially remote code execution.\n\nMany platforms implement stack overflow protections which would mitigate\nagainst the risk of remote code execution. The risk may be further\nmitigated based on stack layout for any given platform/compiler.\n\nPre-announcements of CVE-2022-3602 described this issue as CRITICAL.\nFurther analysis based on some of the mitigating factors described above\nhave led this to be downgraded to HIGH. Users are still encouraged to\nupgrade to a new version as soon as possible.\n\nIn a TLS client, this can be triggered by connecting to a malicious\nserver. In a TLS server, this can be triggered if the server requests\nclient authentication and a malicious client connects.",
      "date": "2022-11-01",
      "aliases": [
        "CVE-2022-3602"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service",
        "code-execution"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20221101.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.11"
      ],
      "unaffected": [
        "<300.0.0"
      ]
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2023-0010",
      "package": "openssl-src",
      "title": "Double free after calling `PEM_read_bio_ex`",
      "description": "The function `PEM_read_bio_ex()` reads a PEM file from a BIO and parses and\ndecodes the \"name\" (e.g. \"CERTIFICATE\"), any header data and the payload data.\nIf the function succeeds then the \"name_out\", \"header\" and \"data\" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case `PEM_read_bio_ex()`\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions `PEM_read_bio()` and `PEM_read()` are simple wrappers around\n`PEM_read_bio_ex()` and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including `PEM_X509_INFO_read_bio_ex()` and\n`SSL_CTX_use_serverinfo_file()` which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if `PEM_read_bio_ex()` returns a failure code. These locations\ninclude the `PEM_read_bio_TYPE()` functions as well as the decoders introduced in\nOpenSSL 3.0.",
      "date": "2023-02-07",
      "aliases": [
        "CVE-2022-4450"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "denial-of-service"
      ],
      "keywords": [],
      "cvss": null,
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20230207.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=111.25, <300.0",
        ">=300.0.12"
      ],
      "unaffected": []
    }
  },
  {
    "advisory": {
      "id": "RUSTSEC-2022-0026",
      "package": "openssl-src",
      "title": "Incorrect MAC key used in the RC4-MD5 ciphersuite",
      "description": "The OpenSSL 3.0 implementation of the RC4-MD5 ciphersuite incorrectly uses the\nAAD data as the MAC key. This makes the MAC key trivially predictable.\n\nAn attacker could exploit this issue by performing a man-in-the-middle attack to\nmodify data being sent from one endpoint to an OpenSSL 3.0 recipient such that\nthe modified data would still pass the MAC integrity check.\n\nNote that data sent from an OpenSSL 3.0 endpoint to a non-OpenSSL 3.0 endpoint\nwill always be rejected by the recipient and the connection will fail at that\npoint. Many application protocols require data to be sent from the client to the\nserver first. Therefore, in such a case, only an OpenSSL 3.0 server would be\nimpacted when talking to a non-OpenSSL 3.0 client.\n\nIf both endpoints are OpenSSL 3.0 then the attacker could modify data being\nsent in both directions. In this case both clients and servers could be\naffected, regardless of the application protocol.\n\nNote that in the absence of an attacker this bug means that an OpenSSL 3.0\nendpoint communicating with a non-OpenSSL 3.0 endpoint will fail to complete the\nhandshake when using this ciphersuite.\n\nThe confidentiality of data is not impacted by this issue, i.e. an attacker\ncannot decrypt data that has been encrypted using this ciphersuite - they can\nonly modify it.\n\nIn order for this attack to work both endpoints must legitimately negotiate the\nRC4-MD5 ciphersuite. This ciphersuite is not compiled by default in OpenSSL 3.0,\nand is not available within the default provider or the default ciphersuite\nlist. This ciphersuite will never be used if TLSv1.3 has been negotiated. In\norder for an OpenSSL 3.0 endpoint to use this ciphersuite the following must\nhave occurred:\n\n1. OpenSSL must have been compiled with the (non-default) compile time option\n   enable-weak-ssl-ciphers\n2. OpenSSL must have had the legacy provider explicitly loaded (either through\n   application code or via configuration)\n3. The ciphersuite must have been explicitly added to the ciphersuite list\n4. The libssl security level must have been set to 0 (default is 1)\n5. A version of SSL/TLS below TLSv1.3 must have been negotiated\n6. Both endpoints must negotiate the RC4-MD5 ciphersuite in preference to any\n   others that both endpoints have in common",
      "date": "2022-05-03",
      "aliases": [
        "CVE-2022-1434"
      ],
      "related": [],
      "collection": "crates",
      "categories": [
        "crypto-failure"
      ],
      "keywords": [],
      "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
      "informational": null,
      "references": [],
      "source": null,
      "url": "https://www.openssl.org/news/secadv/20220503.txt",
      "withdrawn": null
    },
    "affected": null,
    "versions": {
      "patched": [
        ">=300.0.6"
      ],
      "unaffected": [
        "<300.0"
      ]
    }
  }
]